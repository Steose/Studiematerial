
# Komplett CRUD-projekt: Fr√•n Planering till Implementation

## Inledning

Detta √§r en omfattande fallstudie som visar hur en erfaren programmerare planerar och implementerar ett komplett CRUD-projekt (Create, Read, Update, Delete) f√∂r hantering av en personlista. Vi f√∂ljer samma systematiska approach som i tidigare exempel, men denna g√•ng f√∂r ett mer komplext system.

**Projekt**: Personhanteringssystem med fullst√§ndig CRUD-funktionalitet

## Fas 1: M√•ls√§ttning och Scope

### üéØ M√•let

> "Jag b√∂rjar alltid med att s√§tta m√•let. Det √§r kritiskt att veta vad programmet ska och inte ska g√∂ra."

**Vad programmet SKA g√∂ra:**
- Lagra information om personer (namn, √•lder, telefon, email)
- L√§gga till nya personer (Create)
- Visa alla personer (Read)
- Uppdatera befintliga personer (Update)
- Ta bort personer (Delete)
- S√∂ka bland personer
- Enkel menybaserad anv√§ndargr√§nssnitt

**Vad programmet INTE ska g√∂ra:**
- Permanent datalagring (ingen databas/fil)
- Avancerad anv√§ndarautentisering
- Grafiskt anv√§ndargr√§nssnitt
- Datavalidering ut√∂ver grundl√§ggande input-hantering

### Varf√∂r √Ñr Tydliga Gr√§nser Viktiga?

- **F√∂rhindrar scope creep**: Projektet v√§xer inte okontrollerat
- **G√∂r planering enklare**: Vet exakt vad som ska byggas
- **Hj√§lper vid prioritering**: Fokusera p√• k√§rnfunktionalitet f√∂rst
- **Underl√§ttar testning**: Tydliga acceptanskriterier

## Fas 2: Krav och Komponenter

### üõ† Verktyg och Metoder

**Identifierade komponenter:**
1. **Person** - Datamodell f√∂r personinformation
2. **PersonHandler** - Business logic f√∂r CRUD-operationer
3. **MenuHandler** - Anv√§ndargr√§nssnitt och menyhantering
4. **Program** - Applikationsstartpunkt och huvudloop

**N√∂dv√§ndiga funktioner:**
- CRUD-operationer f√∂r person-objekt
- Menybaserat gr√§nssnitt
- S√∂kmekanism
- Input-validering och felhantering

### Systemarkitektur

```plaintext
Program.cs (Main)
    ‚Üì skapar och anv√§nder
MenuHandler.cs (UI Layer)
    ‚Üì anv√§nder
PersonHandler.cs (Business Logic)
    ‚Üì hanterar
Person.cs (Data Model)
```

## Fas 3: Strukturell Design

### üß© Struktur och Separation of Concerns

**Principen "En klass, ett ansvar":**

- **`Person.cs`**: Datamodell - inneh√•ller bara persondata
- **`PersonHandler.cs`**: Business logic - hanterar alla operationer p√• persondata
- **`MenuHandler.cs`**: UI-logic - hanterar anv√§ndarinteraktion
- **`Program.cs`**: Startpunkt - minimal kod som startar applikationen

### üìú Namnstandard

**Konsekventa namn f√∂r f√∂rb√§ttrad l√§sbarhet:**
- Alla klasser anv√§nder PascalCase: `PersonHandler`, `MenuHandler`
- Metoder beskriver action: `AddPerson`, `RemovePerson`, `PrintPersons`
- Engelska namn f√∂r kod, svenska f√∂r kommentarer och UI
- Enums f√∂ljer samma namnm√∂nster som relaterade metoder

## Fas 4: Detaljplanering

### Pseudokod f√∂r Varje Komponent

#### Person.cs
```plaintext
class Person
    properties:
        string Namn
        int √Ölder
        string Telefonnummer
        string Epost

    // Enkel datacontainer utan business logic
```

#### PersonHandler.cs
```plaintext
class PersonHandler
    private List<Person> personer

    methods:
        void AddPerson(Person person)
        void RemovePerson(Person person)
        void UpdatePerson(Person person)
        void PrintPersons()
        List<Person> SearchPersons(string searchTerm)
```

#### MenuHandler.cs
```plaintext
class MenuHandler
    methods:
        void ShowMenu()
        MenuOption ReadMenuChoice()
        void HandleMenuOption(MenuOption option)

    private helper methods:
        void AddPersonUI()
        void RemovePersonUI()
        void UpdatePersonUI()
        // etc.
```

#### Program.cs
```plaintext
class Program
    static void Main()
        create MenuHandler
        while (true)
            show menu
            read choice
            handle choice
```

## Fas 5: Implementation

### Person.cs - Datamodellen

```csharp
/// <summary>
/// Representerar en person med grundl√§ggande kontaktinformation.
/// Denna klass fungerar som en datacontainer utan business logic.
/// </summary>
public class Person
{
    /// <summary>
    /// Personens fullst√§ndiga namn.
    /// </summary>
    public string Namn { get; set; }

    /// <summary>
    /// Personens √•lder i √•r.
    /// </summary>
    public int √Ölder { get; set; }

    /// <summary>
    /// Personens telefonnummer.
    /// </summary>
    public string Telefonnummer { get; set; }

    /// <summary>
    /// Personens e-postadress.
    /// </summary>
    public string Epost { get; set; }

    /// <summary>
    /// Skapar en tom person-instans.
    /// </summary>
    public Person() { }

    /// <summary>
    /// Skapar en person med all n√∂dv√§ndig information.
    /// </summary>
    public Person(string namn, int √•lder, string telefonnummer, string epost)
    {
        Namn = namn;
        √Ölder = √•lder;
        Telefonnummer = telefonnummer;
        Epost = epost;
    }

    /// <summary>
    /// Returnerar en str√§ng representation av personen.
    /// </summary>
    public override string ToString()
    {
        return $"{Namn}, {√Ölder} √•r, Tel: {Telefonnummer}, Email: {Epost}";
    }
}
```

### PersonHandler.cs - Business Logic

```csharp
/// <summary>
/// Hanterar alla operationer relaterade till person-objekt.
/// Denna klass inneh√•ller business logic f√∂r CRUD-operationer.
/// </summary>
public class PersonHandler
{
    /// <summary>
    /// Intern lista som lagrar alla personer.
    /// </summary>
    private List<Person> persons = new List<Person>();

    /// <summary>
    /// L√§gger till en ny person i listan.
    /// </summary>
    /// <param name="person">Personen som ska l√§ggas till</param>
    public void AddPerson(Person person)
    {
        if (person == null)
        {
            Console.WriteLine("Fel: Person kan inte vara null.");
            return;
        }

        if (string.IsNullOrWhiteSpace(person.Namn))
        {
            Console.WriteLine("Fel: Person m√•ste ha ett namn.");
            return;
        }

        persons.Add(person);
        Console.WriteLine($"‚úì {person.Namn} har lagts till i systemet.");
    }

    /// <summary>
    /// Tar bort en person fr√•n listan baserat p√• namn.
    /// </summary>
    /// <param name="namn">Namnet p√• personen som ska tas bort</param>
    public bool RemovePerson(string namn)
    {
        Person personToRemove = persons.Find(p => p.Namn.Equals(namn, StringComparison.OrdinalIgnoreCase));

        if (personToRemove != null)
        {
            persons.Remove(personToRemove);
            Console.WriteLine($"‚úì {namn} har tagits bort fr√•n systemet.");
            return true;
        }
        else
        {
            Console.WriteLine($"‚úó Ingen person med namnet '{namn}' hittades.");
            return false;
        }
    }

    /// <summary>
    /// Uppdaterar en befintlig person baserat p√• namn.
    /// </summary>
    /// <param name="updatedPerson">Person med uppdaterad information</param>
    public bool UpdatePerson(Person updatedPerson)
    {
        if (updatedPerson == null || string.IsNullOrWhiteSpace(updatedPerson.Namn))
        {
            Console.WriteLine("Fel: Ogiltig personinformation.");
            return false;
        }

        int index = persons.FindIndex(p => p.Namn.Equals(updatedPerson.Namn, StringComparison.OrdinalIgnoreCase));

        if (index != -1)
        {
            persons[index] = updatedPerson;
            Console.WriteLine($"‚úì Information f√∂r {updatedPerson.Namn} har uppdaterats.");
            return true;
        }
        else
        {
            Console.WriteLine($"‚úó Ingen person med namnet '{updatedPerson.Namn}' hittades f√∂r uppdatering.");
            return false;
        }
    }

    /// <summary>
    /// Skriver ut alla personer i en formaterad lista.
    /// </summary>
    public void PrintPersons()
    {
        if (persons.Count == 0)
        {
            Console.WriteLine("üìù Inga personer registrerade √§n.");
            return;
        }

        Console.WriteLine("\nüìã Alla registrerade personer:");
        Console.WriteLine("".PadRight(60, '‚îÄ'));

        for (int i = 0; i < persons.Count; i++)
        {
            Console.WriteLine($"{i + 1:D2}. {persons[i]}");
        }

        Console.WriteLine("".PadRight(60, '‚îÄ'));
        Console.WriteLine($"Totalt: {persons.Count} personer");
    }

    /// <summary>
    /// S√∂ker efter personer baserat p√• en s√∂kterm.
    /// </summary>
    /// <param name="searchTerm">S√∂kterm att matcha mot namn</param>
    /// <returns>Lista med matchande personer</returns>
    public List<Person> SearchPersons(string searchTerm)
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            return new List<Person>();
        }

        return persons.FindAll(p => p.Namn.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Returnerar antalet personer i systemet.
    /// </summary>
    public int GetPersonCount()
    {
        return persons.Count;
    }

    /// <summary>
    /// Kontrollerar om en person med givet namn redan finns.
    /// </summary>
    public bool PersonExists(string namn)
    {
        return persons.Any(p => p.Namn.Equals(namn, StringComparison.OrdinalIgnoreCase));
    }
}
```

### MenuHandler.cs - Anv√§ndargr√§nssnitt

```csharp
/// <summary>
/// Hanterar all anv√§ndarinteraktion och menyvisning.
/// Denna klass fungerar som bryggan mellan anv√§ndaren och business logic.
/// </summary>
public class MenuHandler
{
    private PersonHandler personHandler;

    /// <summary>
    /// Skapar en ny MenuHandler med tillh√∂rande PersonHandler.
    /// </summary>
    public MenuHandler()
    {
        personHandler = new PersonHandler();
    }

    /// <summary>
    /// Enum som definierar alla tillg√§ngliga menyalternativ.
    /// </summary>
    public enum MenuOption
    {
        AddPerson = 1,
        RemovePerson = 2,
        UpdatePerson = 3,
        PrintPersons = 4,
        SearchPersons = 5,
        Exit = 6
    }

    /// <summary>
    /// Visar huvudmenyn med alla tillg√§ngliga alternativ.
    /// </summary>
    public void ShowMenu()
    {
        Console.Clear();
        Console.WriteLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Console.WriteLine("‚ïë        PERSONHANTERINGSSYSTEM      ‚ïë");
        Console.WriteLine("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        Console.WriteLine("‚ïë 1. L√§gg till person               ‚ïë");
        Console.WriteLine("‚ïë 2. Ta bort person                 ‚ïë");
        Console.WriteLine("‚ïë 3. Uppdatera person               ‚ïë");
        Console.WriteLine("‚ïë 4. Visa alla personer             ‚ïë");
        Console.WriteLine("‚ïë 5. S√∂k personer                   ‚ïë");
        Console.WriteLine("‚ïë 6. Avsluta                        ‚ïë");
        Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        Console.WriteLine($"Antal registrerade personer: {personHandler.GetPersonCount()}");
    }

    /// <summary>
    /// L√§ser in och validerar anv√§ndarens menyval.
    /// </summary>
    /// <returns>Giltigt menyval</returns>
    public MenuOption ReadMenuChoice()
    {
        while (true)
        {
            Console.Write("\n‚û§ V√§lj alternativ (1-6): ");
            string input = Console.ReadLine();

            if (int.TryParse(input, out int choice) && choice >= 1 && choice <= 6)
            {
                return (MenuOption)choice;
            }
            else
            {
                Console.WriteLine("‚ùå Ogiltigt val. Ange en siffra mellan 1 och 6.");
            }
        }
    }

    /// <summary>
    /// Hanterar det valda menyalternativet genom att anropa r√§tt metod.
    /// </summary>
    /// <param name="menuOption">Det valda menyalternativet</param>
    public void HandleMenuOption(MenuOption menuOption)
    {
        switch (menuOption)
        {
            case MenuOption.AddPerson:
                AddPersonUI();
                break;
            case MenuOption.RemovePerson:
                RemovePersonUI();
                break;
            case MenuOption.UpdatePerson:
                UpdatePersonUI();
                break;
            case MenuOption.PrintPersons:
                PrintPersonsUI();
                break;
            case MenuOption.SearchPersons:
                SearchPersonsUI();
                break;
            case MenuOption.Exit:
                ExitApplication();
                break;
            default:
                Console.WriteLine("‚ùå Ogiltigt menyval.");
                break;
        }

        if (menuOption != MenuOption.Exit)
        {
            Console.WriteLine("\nTryck Enter f√∂r att forts√§tta...");
            Console.ReadLine();
        }
    }

    /// <summary>
    /// UI f√∂r att l√§gga till en ny person.
    /// </summary>
    private void AddPersonUI()
    {
        Console.WriteLine("\n‚ûï L√ÑGG TILL NY PERSON");
        Console.WriteLine("".PadRight(30, '‚îÄ'));

        Person person = new Person();

        Console.Write("Namn: ");
        person.Namn = Console.ReadLine();

        if (personHandler.PersonExists(person.Namn))
        {
            Console.WriteLine($"‚ö†Ô∏è  En person med namnet '{person.Namn}' finns redan.");
            return;
        }

        Console.Write("√Ölder: ");
        while (!int.TryParse(Console.ReadLine(), out int √•lder) || √•lder < 0 || √•lder > 150)
        {
            Console.Write("Ange en giltig √•lder (0-150): ");
        }
        person.√Ölder = √•lder;

        Console.Write("Telefonnummer: ");
        person.Telefonnummer = Console.ReadLine();

        Console.Write("E-post: ");
        person.Epost = Console.ReadLine();

        personHandler.AddPerson(person);
    }

    /// <summary>
    /// UI f√∂r att ta bort en person.
    /// </summary>
    private void RemovePersonUI()
    {
        Console.WriteLine("\n‚ûñ TA BORT PERSON");
        Console.WriteLine("".PadRight(30, '‚îÄ'));

        if (personHandler.GetPersonCount() == 0)
        {
            Console.WriteLine("üìù Inga personer att ta bort.");
            return;
        }

        Console.Write("Ange namn p√• person att ta bort: ");
        string namn = Console.ReadLine();

        personHandler.RemovePerson(namn);
    }

    /// <summary>
    /// UI f√∂r att uppdatera en befintlig person.
    /// </summary>
    private void UpdatePersonUI()
    {
        Console.WriteLine("\n‚úèÔ∏è  UPPDATERA PERSON");
        Console.WriteLine("".PadRight(30, '‚îÄ'));

        if (personHandler.GetPersonCount() == 0)
        {
            Console.WriteLine("üìù Inga personer att uppdatera.");
            return;
        }

        Console.Write("Ange namn p√• person att uppdatera: ");
        string namn = Console.ReadLine();

        if (!personHandler.PersonExists(namn))
        {
            Console.WriteLine($"‚úó Ingen person med namnet '{namn}' hittades.");
            return;
        }

        Console.WriteLine("Ange ny information:");
        Person updatedPerson = new Person { Namn = namn };

        Console.Write("Ny √•lder: ");
        while (!int.TryParse(Console.ReadLine(), out int √•lder) || √•lder < 0 || √•lder > 150)
        {
            Console.Write("Ange en giltig √•lder (0-150): ");
        }
        updatedPerson.√Ölder = √•lder;

        Console.Write("Nytt telefonnummer: ");
        updatedPerson.Telefonnummer = Console.ReadLine();

        Console.Write("Ny e-post: ");
        updatedPerson.Epost = Console.ReadLine();

        personHandler.UpdatePerson(updatedPerson);
    }

    /// <summary>
    /// UI f√∂r att visa alla personer.
    /// </summary>
    private void PrintPersonsUI()
    {
        Console.WriteLine("\nüë• ALLA PERSONER");
        personHandler.PrintPersons();
    }

    /// <summary>
    /// UI f√∂r att s√∂ka efter personer.
    /// </summary>
    private void SearchPersonsUI()
    {
        Console.WriteLine("\nüîç S√ñK PERSONER");
        Console.WriteLine("".PadRight(30, '‚îÄ'));

        Console.Write("Ange s√∂kterm: ");
        string searchTerm = Console.ReadLine();

        List<Person> searchResults = personHandler.SearchPersons(searchTerm);

        if (searchResults.Count == 0)
        {
            Console.WriteLine($"üîç Inga personer hittades som matchar '{searchTerm}'.");
        }
        else
        {
            Console.WriteLine($"\nüîç Hittade {searchResults.Count} person(er):");
            Console.WriteLine("".PadRight(50, '‚îÄ'));
            for (int i = 0; i < searchResults.Count; i++)
            {
                Console.WriteLine($"{i + 1}. {searchResults[i]}");
            }
        }
    }

    /// <summary>
    /// Avslutar applikationen p√• ett kontrollerat s√§tt.
    /// </summary>
    private void ExitApplication()
    {
        Console.WriteLine("\nüëã Tack f√∂r att du anv√§nde personhanteringssystemet!");
        Console.WriteLine("Programmet avslutas...");
        Environment.Exit(0);
    }
}
```

### Program.cs - Startpunkt

```csharp
/// <summary>
/// Huvudklass som startar applikationen.
/// H√•ller minimal kod enligt best practice.
/// </summary>
class Program
{
    /// <summary>
    /// Applikationens startpunkt.
    /// </summary>
    /// <param name="args">Kommandoradsargument (anv√§nds ej)</param>
    static void Main(string[] args)
    {
        // Skapa MenuHandler-instans utanf√∂r loopen f√∂r att undvika on√∂dig recreation
        MenuHandler menuHandler = new MenuHandler();

        // Huvudloop som h√•ller applikationen ig√•ng
        while (true)
        {
            // Visa meny
            menuHandler.ShowMenu();

            // L√§s anv√§ndarens val
            MenuHandler.MenuOption choice = menuHandler.ReadMenuChoice();

            // Hantera valet
            menuHandler.HandleMenuOption(choice);
        }
    }
}
```

## Fas 6: Designprincieper och Best Practices

### Separation of Concerns

**Varje klass har ett tydligt ansvar:**

1. **Person**: Datamodell utan business logic
2. **PersonHandler**: All business logic f√∂r person-operationer
3. **MenuHandler**: UI-logic och anv√§ndarinteraktion
4. **Program**: Minimal startpunkt

### Konsistent Namngivning

**Observera m√∂nstret:**
- MenuHandler.MenuOption enum-v√§rden: `AddPerson`, `RemovePerson`, etc.
- PersonHandler metoder: `AddPerson()`, `RemovePerson()`, etc.
- MenuHandler UI-metoder: `AddPersonUI()`, `RemovePersonUI()`, etc.

**Detta g√∂r att:**
- Koden √§r l√§tt att f√∂lja och f√∂rst√•
- Relationerna mellan komponenter √§r tydliga
- Nya utvecklare snabbt f√∂rst√•r strukturen

### Felhantering och Validering

**Olika niv√•er av validering:**
- **Input-validering**: MenuHandler kontrollerar anv√§ndarinput
- **Business logic-validering**: PersonHandler kontrollerar aff√§rsregler
- **Data-validering**: Grundl√§ggande null-checks och v√§rdeomr√•den

## Fas 7: M√∂jliga F√∂rb√§ttringar

### Immediate Enhancements

1. **Databest√§ndighet**
```csharp
public class FilePersonHandler : PersonHandler
{
    public void SaveToFile(string filename) { /* Implementation */ }
    public void LoadFromFile(string filename) { /* Implementation */ }
}
```

2. **Avancerad s√∂kning**
```csharp
public List<Person> SearchByAge(int minAge, int maxAge) { /* Implementation */ }
public List<Person> SearchByEmail(string emailDomain) { /* Implementation */ }
```

3. **Import/Export funktionalitet**
```csharp
public void ExportToCsv(string filename) { /* Implementation */ }
public void ImportFromCsv(string filename) { /* Implementation */ }
```

### Arkitektuell F√∂rb√§ttringar

1. **Interface-baserad design**
```csharp
public interface IPersonHandler
{
    void AddPerson(Person person);
    bool RemovePerson(string namn);
    // etc.
}
```

2. **Dependency Injection**
```csharp
public MenuHandler(IPersonHandler personHandler)
{
    this.personHandler = personHandler;
}
```

3. **Event-driven arkitektur**
```csharp
public event EventHandler<PersonEventArgs> PersonAdded;
public event EventHandler<PersonEventArgs> PersonRemoved;
```

## √ñvningar och Till√§mpningar

### √ñvning 1: Utvidga Funktionalitet

L√§gg till f√∂ljande funktioner till systemet:
1. Sortera personer efter namn eller √•lder
2. Exportera personlista till textfil
3. Visa statistik (medel√•lder, yngst, √§ldst)
4. √Öngra senaste operation

### √ñvning 2: F√∂rb√§ttra Anv√§ndargr√§nssnittet

1. L√§gg till f√§rgkodning f√∂r olika typer av meddelanden
2. Implementera paginering f√∂r l√•nga listor
3. L√§gg till shortcuts f√∂r vanliga operationer
4. F√∂rb√§ttra input-validering med mer detaljerade felmeddelanden

### √ñvning 3: Refaktorering

1. Extrahera gemensamma UI-m√∂nster till basklasser
2. Implementera Repository-m√∂nstret f√∂r datahantering
3. L√§gg till enhetstester f√∂r alla business logic-metoder
4. Implementera logging f√∂r alla operationer

### √ñvning 4: Ny Feature - Grupper

Utvidga systemet med gruppfunktionalitet:
1. Skapa Group-klass
2. L√•t personer tillh√∂ra grupper
3. L√§gg till CRUD-operationer f√∂r grupper
4. Implementera gruppbaserad s√∂kning och filtrering

## Reflektion och L√§rdomar

### Vad Gjorde Denna Approach Framg√•ngsrik?

1. **Tydlig separation**: Varje klass hade ett specifikt ansvar
2. **Konsistent design**: M√∂nster upprepades genom hela systemet
3. **Gradvis komplexitet**: Byggde fr√•n enkla till mer komplexa funktioner
4. **Anv√§ndbarhet f√∂rsta**: UI designades f√∂r faktisk anv√§ndning

### Viktiga Designbeslut

1. **Objekt-kommunikation**: PersonHandler kommunicerar endast via Person-objekt
2. **Enum f√∂r menyval**: G√∂r koden mer l√§sbar √§n magiska nummer
3. **Single instance**: MenuHandler skapas en g√•ng, inte i varje loop-iteration
4. **Defensive programming**: Validering p√• flera niv√•er

### Lessons Learned

- **Planering sparar tid**: Noggrann planering fr√•n b√∂rjan f√∂rhindrade stora omskrivningar
- **Konsistens √§r kung**: Enhetliga m√∂nster g√∂r koden f√∂ruts√§gbar
- **Start enkelt**: Grundfunktionalitet f√∂rst, sedan f√∂rb√§ttringar
- **Testa tidigt**: Varje komponent testades isolerat f√∂re integration

## Sammanfattning

Detta projekt visar hur systematisk planering och god arkitektur leder till underh√•llbar, utvidgbar kod. Nyckelprincieperna som till√§mpades:

1. **Tydliga ansvarsomr√•den** f√∂r varje klass
2. **Konsistent namngivning** genom hela systemet
3. **Separation av concerns** mellan UI, business logic och data
4. **Defensive programming** med validering p√• flera niv√•er
5. **Anv√§ndarv√§nligt gr√§nssnitt** med tydlig feedback

Som Marcus sammanfattar: "F√∂r att h√•lla koden organiserad och l√§ttl√§st anv√§nds 'Handlers' f√∂r olika uppgifter. Detta skapar fokus p√• en del av projektet i taget."

Denna approach resulterar i kod som √§r:
- **L√§tt att f√∂rst√•**: Tydlig struktur och ansvar
- **L√§tt att underh√•lla**: √Ñndringar p√•verkar endast relevanta delar
- **L√§tt att utvidga**: Nya funktioner kan l√§ggas till utan att f√∂rst√∂ra befintlig kod
- **L√§tt att testa**: Varje komponent kan testas isolerat

üåü Detta √§r grunden f√∂r professionell mjukvaruutveckling! üåü

